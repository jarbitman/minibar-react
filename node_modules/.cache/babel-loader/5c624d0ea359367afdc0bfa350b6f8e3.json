{"ast":null,"code":"import e, { Component as o } from \"react\";\nimport t from \"prop-types\";\nimport n from \"react-dom\";\nimport i from \"eventemitter3\";\nimport r from \"@mapbox/point-geometry\";\n\nfunction s() {\n  return (s = Object.assign || function (e) {\n    for (var o = 1; o < arguments.length; o++) {\n      var t = arguments[o];\n\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nfunction a(e, o) {\n  e.prototype = Object.create(o.prototype), e.prototype.constructor = e, e.__proto__ = o;\n}\n\nfunction p(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nvar l = {\n  width: \"100%\",\n  height: \"100%\",\n  left: 0,\n  top: 0,\n  margin: 0,\n  padding: 0,\n  position: \"absolute\"\n},\n    u = function (o) {\n  function t() {\n    return o.apply(this, arguments) || this;\n  }\n\n  a(t, o);\n  var n = t.prototype;\n  return n.shouldComponentUpdate = function () {\n    return !1;\n  }, n.render = function () {\n    return e.createElement(\"div\", {\n      ref: this.props.registerChild,\n      style: l\n    });\n  }, t;\n}(o),\n    h = function (e) {\n  function o(o) {\n    var t;\n    return (t = e.call(this) || this).gmapInstance = o, t;\n  }\n\n  a(o, e);\n  var t = o.prototype;\n  return t.getChildren = function () {\n    return this.gmapInstance.props.children;\n  }, t.getMousePosition = function () {\n    return this.gmapInstance.mouse_;\n  }, t.getUpdateCounter = function () {\n    return this.gmapInstance.updateCounter_;\n  }, t.dispose = function () {\n    this.gmapInstance = null, this.removeAllListeners();\n  }, o;\n}(i),\n    c = function (e, o) {\n  for (var t = s({}, e), n = 0; n < o.length; n++) {\n    var i = o[n];\n    i in t && delete t[i];\n  }\n\n  return t;\n},\n    d = Object.prototype.hasOwnProperty;\n\nfunction m(e, o) {\n  return e === o ? 0 !== e || 0 !== o || 1 / e == 1 / o : e != e && o != o;\n}\n\nfunction g(e, o) {\n  if (m(e, o)) return !0;\n  if (\"object\" != typeof e || null === e || \"object\" != typeof o || null === o) return !1;\n  var t = Object.keys(e),\n      n = Object.keys(o);\n  if (t.length !== n.length) return !1;\n\n  for (var i = 0; i < t.length; i++) if (!d.call(o, t[i]) || !m(e[t[i]], o[t[i]])) return !1;\n\n  return !0;\n}\n\nvar _ = {\n  width: \"100%\",\n  height: \"100%\",\n  left: 0,\n  top: 0,\n  margin: 0,\n  padding: 0,\n  position: \"absolute\"\n},\n    f = {\n  width: 0,\n  height: 0,\n  left: 0,\n  top: 0,\n  backgroundColor: \"transparent\",\n  position: \"absolute\"\n},\n    v = function (o) {\n  function t(t) {\n    var n;\n    return (n = o.call(this, t) || this)._getState = function () {\n      return {\n        children: n.props.dispatcher.getChildren(),\n        updateCounter: n.props.dispatcher.getUpdateCounter()\n      };\n    }, n._onChangeHandler = function () {\n      if (n.dimensionsCache_) {\n        var e = (n.state.children || []).length,\n            o = n._getState();\n\n        n.setState(o, function () {\n          return (o.children || []).length !== e && n._onMouseChangeHandler();\n        });\n      }\n    }, n._onChildClick = function () {\n      n.props.onChildClick && n.hoverChildProps_ && n.props.onChildClick(n.hoverKey_, n.hoverChildProps_);\n    }, n._onChildMouseDown = function () {\n      n.props.onChildMouseDown && n.hoverChildProps_ && n.props.onChildMouseDown(n.hoverKey_, n.hoverChildProps_);\n    }, n._onChildMouseEnter = function (e, o) {\n      n.dimensionsCache_ && (n.props.onChildMouseEnter && n.props.onChildMouseEnter(e, o), n.hoverChildProps_ = o, n.hoverKey_ = e, n.setState({\n        hoverKey: e\n      }));\n    }, n._onChildMouseLeave = function () {\n      if (n.dimensionsCache_) {\n        var e = n.hoverKey_;\n        null != e && (n.props.onChildMouseLeave && n.props.onChildMouseLeave(e, n.hoverChildProps_), n.hoverKey_ = null, n.hoverChildProps_ = null, n.setState({\n          hoverKey: null\n        }));\n      }\n    }, n._onMouseAllow = function (e) {\n      e || n._onChildMouseLeave(), n.allowMouse_ = e;\n    }, n._onMouseChangeHandler = function () {\n      n.allowMouse_ && n._onMouseChangeHandlerRaf();\n    }, n._onMouseChangeHandlerRaf = function () {\n      if (n.dimensionsCache_) {\n        var o = n.props.dispatcher.getMousePosition();\n\n        if (o) {\n          var t = [],\n              i = n.props.getHoverDistance();\n\n          if (e.Children.forEach(n.state.children, function (e, r) {\n            if (e && (void 0 !== e.props.latLng || void 0 !== e.props.lat || void 0 !== e.props.lng)) {\n              var s = null != e.key ? e.key : r,\n                  a = n.props.distanceToMouse(n.dimensionsCache_[s], o, e.props);\n              a < i && t.push({\n                key: s,\n                dist: a,\n                props: e.props\n              });\n            }\n          }), t.length) {\n            t.sort(function (e, o) {\n              return e.dist - o.dist;\n            });\n            var r = t[0].key,\n                s = t[0].props;\n            n.hoverKey_ !== r && (n._onChildMouseLeave(), n._onChildMouseEnter(r, s));\n          } else n._onChildMouseLeave();\n        } else n._onChildMouseLeave();\n      }\n    }, n._getDimensions = function (e) {\n      return n.dimensionsCache_[e];\n    }, n.dimensionsCache_ = {}, n.hoverKey_ = null, n.hoverChildProps_ = null, n.allowMouse_ = !0, n.state = s({}, n._getState(), {\n      hoverKey: null\n    }), n;\n  }\n\n  a(t, o);\n  var n = t.prototype;\n  return n.componentDidMount = function () {\n    this.props.dispatcher.on(\"kON_CHANGE\", this._onChangeHandler), this.props.dispatcher.on(\"kON_MOUSE_POSITION_CHANGE\", this._onMouseChangeHandler), this.props.dispatcher.on(\"kON_CLICK\", this._onChildClick), this.props.dispatcher.on(\"kON_MDOWN\", this._onChildMouseDown);\n  }, n.shouldComponentUpdate = function (e, o) {\n    return !0 === this.props.experimental ? !g(this.props, e) || !g(c(this.state, [\"hoverKey\"]), c(o, [\"hoverKey\"])) : !g(this.props, e) || !g(this.state, o);\n  }, n.componentWillUnmount = function () {\n    this.props.dispatcher.removeListener(\"kON_CHANGE\", this._onChangeHandler), this.props.dispatcher.removeListener(\"kON_MOUSE_POSITION_CHANGE\", this._onMouseChangeHandler), this.props.dispatcher.removeListener(\"kON_CLICK\", this._onChildClick), this.props.dispatcher.removeListener(\"kON_MDOWN\", this._onChildMouseDown), this.dimensionsCache_ = null;\n  }, n.render = function () {\n    var o = this,\n        t = this.props.style || _;\n    this.dimensionsCache_ = {};\n    var n = e.Children.map(this.state.children, function (t, n) {\n      if (t) {\n        if (void 0 === t.props.latLng && void 0 === t.props.lat && void 0 === t.props.lng) return e.cloneElement(t, {\n          $geoService: o.props.geoService,\n          $onMouseAllow: o._onMouseAllow,\n          $prerender: o.props.prerender\n        });\n        var i = void 0 !== t.props.latLng ? t.props.latLng : {\n          lat: t.props.lat,\n          lng: t.props.lng\n        },\n            r = o.props.insideMapPanes ? o.props.geoService.fromLatLngToDivPixel(i) : o.props.geoService.fromLatLngToCenterPixel(i),\n            a = {\n          left: r.x,\n          top: r.y\n        };\n\n        if (void 0 !== t.props.seLatLng || void 0 !== t.props.seLat && void 0 !== t.props.seLng) {\n          var p = void 0 !== t.props.seLatLng ? t.props.seLatLng : {\n            lat: t.props.seLat,\n            lng: t.props.seLng\n          },\n              l = o.props.insideMapPanes ? o.props.geoService.fromLatLngToDivPixel(p) : o.props.geoService.fromLatLngToCenterPixel(p);\n          a.width = l.x - r.x, a.height = l.y - r.y;\n        }\n\n        var u = o.props.geoService.fromLatLngToContainerPixel(i),\n            h = null != t.key ? t.key : n;\n        return o.dimensionsCache_[h] = s({\n          x: u.x,\n          y: u.y\n        }, i), e.createElement(\"div\", {\n          key: h,\n          style: s({}, f, a),\n          className: t.props.$markerHolderClassName\n        }, e.cloneElement(t, {\n          $hover: h === o.state.hoverKey,\n          $getDimensions: o._getDimensions,\n          $dimensionKey: h,\n          $geoService: o.props.geoService,\n          $onMouseAllow: o._onMouseAllow,\n          $prerender: o.props.prerender\n        }));\n      }\n    });\n    return e.createElement(\"div\", {\n      style: t\n    }, n);\n  }, t;\n}(o);\n\nv.propTypes = {\n  geoService: t.any,\n  style: t.any,\n  distanceToMouse: t.func,\n  dispatcher: t.any,\n  onChildClick: t.func,\n  onChildMouseDown: t.func,\n  onChildMouseLeave: t.func,\n  onChildMouseEnter: t.func,\n  getHoverDistance: t.func,\n  insideMapPanes: t.bool,\n  prerender: t.bool\n}, v.defaultProps = {\n  insideMapPanes: !1,\n  prerender: !1\n};\nvar M = {\n  width: \"50%\",\n  height: \"50%\",\n  left: \"50%\",\n  top: \"50%\",\n  margin: 0,\n  padding: 0,\n  position: \"absolute\"\n};\n\nfunction y(o) {\n  return e.createElement(\"div\", {\n    style: M\n  }, e.createElement(v, s({}, o, {\n    prerender: !0\n  })));\n}\n\nvar C,\n    w,\n    L = null,\n    b = new Promise(function (e) {\n  w = e;\n}),\n    D = function (e, o) {\n  return L || (L = require(\"scriptjs\")), e ? C || (C = new Promise(function (t, n) {\n    if (\"undefined\" != typeof window) {\n      if (window.google && window.google.maps) t(window.google.maps);else {\n        if (void 0 !== window._$_google_map_initialize_$_ && n(new Error(\"google map initialization error\")), window._$_google_map_initialize_$_ = function () {\n          delete window._$_google_map_initialize_$_, t(window.google.maps);\n        }, \"production\" !== process.env.NODE_ENV && Object.keys(e).indexOf(\"callback\") > -1) {\n          var i = '\"callback\" key in bootstrapURLKeys is not allowed,\\n                          use onGoogleApiLoaded property instead';\n          throw console.error(i), new Error(i);\n        }\n\n        var r = Object.keys(e).reduce(function (o, t) {\n          return o + \"&\" + t + \"=\" + e[t];\n        }, \"\");\n        L(\"https://maps.googleapis.com/maps/api/js?callback=_$_google_map_initialize_$_\" + r + (o ? \"&libraries=visualization\" : \"\"), function () {\n          return void 0 === window.google && n(new Error(\"google map initialization error (not loaded)\"));\n        });\n      }\n    } else n(new Error(\"google map cannot be loaded outside browser env\"));\n  }), w(C), C) : b;\n};\n\nfunction z(e, o, t) {\n  var n = t - o;\n  return e === t ? e : ((e - o) % n + n) % n + o;\n}\n\nvar k = function () {\n  function e(e, o) {\n    if (isNaN(e) || isNaN(o)) throw new Error(\"Invalid LatLng object: (\" + e + \", \" + o + \")\");\n    this.lat = +e, this.lng = +o;\n  }\n\n  return e.prototype.wrap = function () {\n    return new e(this.lat, z(this.lng, -180, 180));\n  }, e;\n}();\n\nk.convert = function (e) {\n  return e instanceof k ? e : Array.isArray(e) ? new k(e[0], e[1]) : \"lng\" in e && \"lat\" in e ? new k(e.lat, e.lng) : e;\n};\n\nvar O = function () {\n  function e(e, o, t) {\n    this.tileSize = e || 512, this._minZoom = o || 0, this._maxZoom = t || 52, this.latRange = [-85.05113, 85.05113], this.width = 0, this.height = 0, this.zoom = 0, this.center = new k(0, 0), this.angle = 0;\n  }\n\n  var o,\n      t = e.prototype;\n  return t.zoomScale = function (e) {\n    return Math.pow(2, e);\n  }, t.scaleZoom = function (e) {\n    return Math.log(e) / Math.LN2;\n  }, t.project = function (e, o) {\n    return new r(this.lngX(e.lng, o), this.latY(e.lat, o));\n  }, t.unproject = function (e, o) {\n    return new k(this.yLat(e.y, o), this.xLng(e.x, o));\n  }, t.lngX = function (e, o) {\n    return (180 + e) * (o || this.worldSize) / 360;\n  }, t.latY = function (e, o) {\n    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) * (o || this.worldSize) / 360;\n  }, t.xLng = function (e, o) {\n    return 360 * e / (o || this.worldSize) - 180;\n  }, t.yLat = function (e, o) {\n    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e / (o || this.worldSize)) * Math.PI / 180)) - 90;\n  }, t.locationPoint = function (e) {\n    var o = this.project(e);\n    return this.centerPoint._sub(this.point._sub(o)._rotate(this.angle));\n  }, t.pointLocation = function (e) {\n    var o = this.centerPoint._sub(e)._rotate(-this.angle);\n\n    return this.unproject(this.point.sub(o));\n  }, (o = [{\n    key: \"minZoom\",\n    get: function () {\n      return this._minZoom;\n    },\n    set: function (e) {\n      this._minZoom = e, this.zoom = Math.max(this.zoom, e);\n    }\n  }, {\n    key: \"maxZoom\",\n    get: function () {\n      return this._maxZoom;\n    },\n    set: function (e) {\n      this._maxZoom = e, this.zoom = Math.min(this.zoom, e);\n    }\n  }, {\n    key: \"worldSize\",\n    get: function () {\n      return this.tileSize * this.scale;\n    }\n  }, {\n    key: \"centerPoint\",\n    get: function () {\n      return new r(0, 0);\n    }\n  }, {\n    key: \"size\",\n    get: function () {\n      return new r(this.width, this.height);\n    }\n  }, {\n    key: \"bearing\",\n    get: function () {\n      return -this.angle / Math.PI * 180;\n    },\n    set: function (e) {\n      this.angle = -z(e, -180, 180) * Math.PI / 180;\n    }\n  }, {\n    key: \"zoom\",\n    get: function () {\n      return this._zoom;\n    },\n    set: function (e) {\n      var o = Math.min(Math.max(e, this.minZoom), this.maxZoom);\n      this._zoom = o, this.scale = this.zoomScale(o), this.tileZoom = Math.floor(o), this.zoomFraction = o - this.tileZoom;\n    }\n  }, {\n    key: \"x\",\n    get: function () {\n      return this.lngX(this.center.lng);\n    }\n  }, {\n    key: \"y\",\n    get: function () {\n      return this.latY(this.center.lat);\n    }\n  }, {\n    key: \"point\",\n    get: function () {\n      return new r(this.x, this.y);\n    }\n  }]) && function (e, o) {\n    for (var t = 0; t < o.length; t++) {\n      var n = o[t];\n      n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n    }\n  }(e.prototype, o), e;\n}(),\n    x = function () {\n  function e(e) {\n    this.hasSize_ = !1, this.hasView_ = !1, this.transform_ = new O(e || 512);\n  }\n\n  var o = e.prototype;\n  return o.setView = function (e, o, t) {\n    this.transform_.center = k.convert(e), this.transform_.zoom = +o, this.transform_.bearing = +t, this.hasView_ = !0;\n  }, o.setViewSize = function (e, o) {\n    this.transform_.width = e, this.transform_.height = o, this.hasSize_ = !0;\n  }, o.setMapCanvasProjection = function (e, o) {\n    this.maps_ = e, this.mapCanvasProjection_ = o;\n  }, o.canProject = function () {\n    return this.hasSize_ && this.hasView_;\n  }, o.hasSize = function () {\n    return this.hasSize_;\n  }, o.fromLatLngToCenterPixel = function (e) {\n    return this.transform_.locationPoint(k.convert(e));\n  }, o.fromLatLngToDivPixel = function (e) {\n    if (this.mapCanvasProjection_) {\n      var o = new this.maps_.LatLng(e.lat, e.lng);\n      return this.mapCanvasProjection_.fromLatLngToDivPixel(o);\n    }\n\n    return this.fromLatLngToCenterPixel(e);\n  }, o.fromLatLngToContainerPixel = function (e) {\n    if (this.mapCanvasProjection_) {\n      var o = new this.maps_.LatLng(e.lat, e.lng);\n      return this.mapCanvasProjection_.fromLatLngToContainerPixel(o);\n    }\n\n    var t = this.fromLatLngToCenterPixel(e);\n    return t.x -= this.transform_.worldSize * Math.round(t.x / this.transform_.worldSize), t.x += this.transform_.width / 2, t.y += this.transform_.height / 2, t;\n  }, o.fromContainerPixelToLatLng = function (e) {\n    if (this.mapCanvasProjection_) {\n      var o = this.mapCanvasProjection_.fromContainerPixelToLatLng(e);\n      return {\n        lat: o.lat(),\n        lng: o.lng()\n      };\n    }\n\n    var t = s({}, e);\n    t.x -= this.transform_.width / 2, t.y -= this.transform_.height / 2;\n    var n = this.transform_.pointLocation(r.convert(t));\n    return n.lng -= 360 * Math.round(n.lng / 360), n;\n  }, o.getWidth = function () {\n    return this.transform_.width;\n  }, o.getHeight = function () {\n    return this.transform_.height;\n  }, o.getZoom = function () {\n    return this.transform_.zoom;\n  }, o.getCenter = function () {\n    return this.transform_.pointLocation({\n      x: 0,\n      y: 0\n    });\n  }, o.getBounds = function (e, o) {\n    var t = e && e[0] || 0,\n        n = e && e[1] || 0,\n        i = e && e[2] || 0,\n        s = e && e[3] || 0;\n\n    if (this.getWidth() - n - s > 0 && this.getHeight() - t - i > 0) {\n      var a = this.transform_.pointLocation(r.convert({\n        x: s - this.getWidth() / 2,\n        y: t - this.getHeight() / 2\n      })),\n          p = this.transform_.pointLocation(r.convert({\n        x: this.getWidth() / 2 - n,\n        y: this.getHeight() / 2 - i\n      })),\n          l = [a.lat, a.lng, p.lat, p.lng, p.lat, a.lng, a.lat, p.lng];\n      return o && (l = l.map(function (e) {\n        return Math.round(e * o) / o;\n      })), l;\n    }\n\n    return [0, 0, 0, 0];\n  }, e;\n}();\n\nfunction S(e) {\n  if (window.requestAnimationFrame) return window.requestAnimationFrame(e);\n  var o = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n  return o ? o(e) : window.setTimeout(e, 1e3 / 60);\n}\n\nvar T = Math.log2 ? Math.log2 : function (e) {\n  return Math.log(e) / Math.LN2;\n};\n\nfunction E(e, o) {\n  return Object.keys(e).reduce(function (t, n) {\n    return o(e[n]) && (t[n] = e[n]), t;\n  }, {});\n}\n\nvar P = function (e) {\n  if (null !== e && \"object\" == typeof e) {\n    if (0 === Object.keys(e).length) return !0;\n  } else if (null == e || \"\" === e) return !0;\n\n  return !1;\n},\n    A = Object.prototype.toString;\n\nfunction I(e) {\n  return \"number\" == typeof e || function (e) {\n    return !!e && \"object\" == typeof e;\n  }(e) && \"[object Number]\" === A.call(e);\n}\n\nvar N = null;\n\nfunction Z() {\n  if (N) return N;\n\n  if (\"undefined\" != typeof navigator) {\n    var e = navigator.userAgent.indexOf(\"MSIE\") > -1,\n        o = navigator.userAgent.indexOf(\"Firefox\") > -1,\n        t = navigator.userAgent.toLowerCase().indexOf(\"op\") > -1,\n        n = navigator.userAgent.indexOf(\"Chrome\") > -1,\n        i = navigator.userAgent.indexOf(\"Safari\") > -1;\n    return n && i && (i = !1), n && t && (n = !1), N = {\n      isExplorer: e,\n      isFirefox: o,\n      isOpera: t,\n      isChrome: n,\n      isSafari: i\n    };\n  }\n\n  return N = {\n    isChrome: !0,\n    isExplorer: !1,\n    isFirefox: !1,\n    isOpera: !1,\n    isSafari: !1\n  };\n}\n\nvar j = function (e) {\n  return Function.prototype.toString.call(e);\n};\n\nfunction U(e) {\n  if (!e || \"object\" != typeof e) return !1;\n  var o = \"function\" == typeof e.constructor ? Object.getPrototypeOf(e) : Object.prototype;\n  if (null === o) return !0;\n  var t = o.constructor;\n  return \"function\" == typeof t && t instanceof t && j(t) === j(Object);\n}\n\nfunction H(e, o, t, n) {\n  e.addEventListener(o, t, function () {\n    var e = !1;\n\n    try {\n      var o = Object.defineProperty({}, \"passive\", {\n        get: function () {\n          e = !0;\n        }\n      });\n      window.addEventListener(\"test\", o, o), window.removeEventListener(\"test\", o, o);\n    } catch (o) {\n      e = !1;\n    }\n\n    return e;\n  }() ? {\n    capture: n,\n    passive: !0\n  } : n);\n}\n\nvar R,\n    K = !(\"undefined\" == typeof window || !window.document || !window.document.createElement);\nR = K ? window : \"undefined\" != typeof self ? self : void 0;\nvar G,\n    B = \"undefined\" != typeof document && document.attachEvent,\n    W = !1;\n\nif (K && !B) {\n  var V = function () {\n    var e = R.requestAnimationFrame || R.mozRequestAnimationFrame || R.webkitRequestAnimationFrame || function (e) {\n      return R.setTimeout(e, 20);\n    };\n\n    return function (o) {\n      return e(o);\n    };\n  }(),\n      F = (G = R.cancelAnimationFrame || R.mozCancelAnimationFrame || R.webkitCancelAnimationFrame || R.clearTimeout, function (e) {\n    return G(e);\n  }),\n      $ = function (e) {\n    var o = e.__resizeTriggers__,\n        t = o.firstElementChild,\n        n = o.lastElementChild,\n        i = t.firstElementChild;\n    n.scrollLeft = n.scrollWidth, n.scrollTop = n.scrollHeight, i.style.width = t.offsetWidth + 1 + \"px\", i.style.height = t.offsetHeight + 1 + \"px\", t.scrollLeft = t.scrollWidth, t.scrollTop = t.scrollHeight;\n  },\n      q = function (e) {\n    var o = this;\n    $(this), this.__resizeRAF__ && F(this.__resizeRAF__), this.__resizeRAF__ = V(function () {\n      (function (e) {\n        return e.offsetWidth != e.__resizeLast__.width || e.offsetHeight != e.__resizeLast__.height;\n      })(o) && (o.__resizeLast__.width = o.offsetWidth, o.__resizeLast__.height = o.offsetHeight, o.__resizeListeners__.forEach(function (t) {\n        t.call(o, e);\n      }));\n    });\n  },\n      Y = !1,\n      X = \"\",\n      J = \"animationstart\",\n      Q = \"Webkit Moz O ms\".split(\" \"),\n      ee = \"webkitAnimationStart animationstart oAnimationStart MSAnimationStart\".split(\" \");\n\n  if (K) {\n    var oe = document.createElement(\"fakeelement\");\n    if (void 0 !== oe.style.animationName && (Y = !0), !1 === Y) for (var te = 0; te < Q.length; te++) if (void 0 !== oe.style[Q[te] + \"AnimationName\"]) {\n      X = \"-\" + Q[te].toLowerCase() + \"-\", J = ee[te], Y = !0;\n      break;\n    }\n  }\n\n  var ne = \"resizeanim\",\n      ie = \"@\" + X + \"keyframes \" + ne + \" { from { opacity: 0; } to { opacity: 0; } } \",\n      re = X + \"animation: 1ms \" + ne + \"; \";\n}\n\nvar se = void 0 !== n.createPortal,\n    ae = se ? n.createPortal : n.unstable_renderSubtreeIntoContainer,\n    pe = function (e) {\n  return U(e) ? e : {\n    lat: e[0],\n    lng: e[1]\n  };\n},\n    le = function (e, o) {\n  return \"production\" !== process.env.NODE_ENV && e < o && console.warn(\"GoogleMap: minZoom option is less than recommended minZoom option for your map sizes.\\noverrided to value \" + o), o < e ? e : o;\n},\n    ue = function (o) {\n  function t(t) {\n    var i;\n\n    if ((i = o.call(this, t) || this)._getMinZoom = function () {\n      if (i.geoService_.getWidth() > 0 || i.geoService_.getHeight() > 0) {\n        var e = Math.ceil(i.geoService_.getWidth() / 256) + 2,\n            o = Math.ceil(i.geoService_.getHeight() / 256) + 2,\n            t = Math.max(e, o);\n        return Math.ceil(T(t));\n      }\n\n      return 3;\n    }, i._computeMinZoom = function (e) {\n      return P(e) ? i._getMinZoom() : e;\n    }, i._mapDomResizeCallback = function () {\n      if (i.resetSizeOnIdle_ = !0, i.maps_) {\n        var e = i.props.center || i.props.defaultCenter,\n            o = i.map_.getCenter();\n        i.maps_.event.trigger(i.map_, \"resize\"), i.map_.setCenter(i.props.resetBoundsOnResize ? e : o);\n      }\n    }, i._setLayers = function (e) {\n      e.forEach(function (e) {\n        i.layers_[e] = new i.maps_[e](), i.layers_[e].setMap(i.map_);\n      });\n    }, i._renderPortal = function () {\n      return e.createElement(v, {\n        experimental: i.props.experimental,\n        onChildClick: i._onChildClick,\n        onChildMouseDown: i._onChildMouseDown,\n        onChildMouseEnter: i._onChildMouseEnter,\n        onChildMouseLeave: i._onChildMouseLeave,\n        geoService: i.geoService_,\n        insideMapPanes: !0,\n        distanceToMouse: i.props.distanceToMouse,\n        getHoverDistance: i._getHoverDistance,\n        dispatcher: i.markersDispatcher_\n      });\n    }, i._initMap = function () {\n      if (!i.initialized_) {\n        i.initialized_ = !0;\n        var e = pe(i.props.center || i.props.defaultCenter);\n        i.geoService_.setView(e, i.props.zoom || i.props.defaultZoom, 0), i._onBoundsChanged();\n        var o = s({}, i.props.apiKey && {\n          key: i.props.apiKey\n        }, i.props.bootstrapURLKeys);\n        i.props.googleMapLoader(o, i.props.heatmapLibrary).then(function (e) {\n          if (i.mounted_) {\n            var o,\n                t,\n                r = i.geoService_.getCenter(),\n                a = {\n              zoom: i.props.zoom || i.props.defaultZoom,\n              center: new e.LatLng(r.lat, r.lng)\n            };\n            i.props.heatmap.positions && (Object.assign(p(i), {\n              heatmap: (o = e, t = i.props.heatmap, new o.visualization.HeatmapLayer({\n                data: t.positions.reduce(function (e, t) {\n                  var n = t.weight,\n                      i = void 0 === n ? 1 : n;\n                  return e.push({\n                    location: new o.LatLng(t.lat, t.lng),\n                    weight: i\n                  }), e;\n                }, [])\n              }))\n            }), function (e, o) {\n              var t = o.options,\n                  n = void 0 === t ? {} : t;\n              Object.keys(n).map(function (o) {\n                return e.set(o, n[o]);\n              });\n            }(i.heatmap, i.props.heatmap));\n\n            var l = E(e, U),\n                u = \"function\" == typeof i.props.options ? i.props.options(l) : i.props.options,\n                h = !P(i.props.draggable) && {\n              draggable: i.props.draggable\n            },\n                c = i._computeMinZoom(u.minZoom);\n\n            i.minZoom_ = c;\n            var d = s({}, {\n              overviewMapControl: !1,\n              streetViewControl: !1,\n              rotateControl: !0,\n              mapTypeControl: !1,\n              styles: [{\n                featureType: \"poi\",\n                elementType: \"labels\",\n                stylers: [{\n                  visibility: \"off\"\n                }]\n              }],\n              minZoom: 3\n            }, {\n              minZoom: c\n            }, u, a);\n            i.defaultDraggableOption_ = P(d.draggable) ? i.defaultDraggableOption_ : d.draggable;\n            var m = s({}, d, h);\n            m.minZoom = le(m.minZoom, c);\n            var g = new e.Map(n.findDOMNode(i.googleMapDom_), m);\n            i.map_ = g, i.maps_ = e, i._setLayers(i.props.layerTypes);\n\n            var _ = e.version.match(/^3\\.(\\d+)\\./),\n                f = _ && Number(_[1]),\n                v = p(i),\n                M = Object.assign(new e.OverlayView(), {\n              onAdd: function () {\n                var o = \"undefined\" != typeof screen ? screen.width + \"px\" : \"2000px\",\n                    t = \"undefined\" != typeof screen ? screen.height + \"px\" : \"2000px\",\n                    n = document.createElement(\"div\");\n\n                if (n.style.backgroundColor = \"transparent\", n.style.position = \"absolute\", n.style.left = \"0px\", n.style.top = \"0px\", n.style.width = o, n.style.height = t, v.props.overlayViewDivStyle) {\n                  var i = v.props.overlayViewDivStyle;\n                  \"object\" == typeof i && Object.keys(i).forEach(function (e) {\n                    n.style[e] = i[e];\n                  });\n                }\n\n                this.getPanes().overlayMouseTarget.appendChild(n), v.geoService_.setMapCanvasProjection(e, M.getProjection()), se ? v.setState({\n                  overlay: n\n                }) : ae(v, v._renderPortal(), n, function () {\n                  return v.setState({\n                    overlay: n\n                  });\n                });\n              },\n              onRemove: function () {\n                var e = v.state.overlay;\n                e && !se && n.unmountComponentAtNode(e), v.setState({\n                  overlay: null\n                });\n              },\n              draw: function () {\n                if (v.updateCounter_++, v._onBoundsChanged(g, e, !v.props.debounced), v.googleApiLoadedCalled_ || (v._onGoogleApiLoaded({\n                  map: g,\n                  maps: e,\n                  ref: v.googleMapDom_\n                }), v.googleApiLoadedCalled_ = !0), v.mouse_) {\n                  var o = v.geoService_.fromContainerPixelToLatLng(v.mouse_);\n                  v.mouse_.lat = o.lat, v.mouse_.lng = o.lng;\n                }\n\n                v._onChildMouseMove(), v.markersDispatcher_ && (v.markersDispatcher_.emit(\"kON_CHANGE\"), v.fireMouseEventOnIdle_ && v.markersDispatcher_.emit(\"kON_MOUSE_POSITION_CHANGE\"));\n              }\n            });\n\n            i.overlay_ = M, M.setMap(g), i.props.heatmap.positions && i.heatmap.setMap(g), i.props.onTilesLoaded && e.event.addListener(g, \"tilesloaded\", function () {\n              v._onTilesLoaded();\n            }), e.event.addListener(g, \"zoom_changed\", function () {\n              v.geoService_.getZoom() !== g.getZoom() && (v.zoomAnimationInProgress_ || (v.zoomAnimationInProgress_ = !0, v._onZoomAnimationStart(g.zoom)), f < 32) && (new Date().getTime() - i.zoomControlClickTime_ < 300 ? S(function () {\n                return S(function () {\n                  v.updateCounter_++, v._onBoundsChanged(g, e);\n                });\n              }) : (v.updateCounter_++, v._onBoundsChanged(g, e)));\n            }), e.event.addListener(g, \"idle\", function () {\n              if (i.resetSizeOnIdle_) {\n                i._setViewSize();\n\n                var o = i._computeMinZoom(u.minZoom);\n\n                o !== i.minZoom_ && (i.minZoom_ = o, g.setOptions({\n                  minZoom: o\n                })), i.resetSizeOnIdle_ = !1;\n              }\n\n              v.zoomAnimationInProgress_ && (v.zoomAnimationInProgress_ = !1, v._onZoomAnimationEnd(g.zoom)), v.updateCounter_++, v._onBoundsChanged(g, e), v.dragTime_ = 0, v.markersDispatcher_ && v.markersDispatcher_.emit(\"kON_CHANGE\");\n            }), e.event.addListener(g, \"mouseover\", function () {\n              v.mouseInMap_ = !0;\n            }), e.event.addListener(g, \"click\", function () {\n              v.mouseInMap_ = !0;\n            }), e.event.addListener(g, \"mouseout\", function () {\n              v.mouseInMap_ = !1, v.mouse_ = null, v.markersDispatcher_.emit(\"kON_MOUSE_POSITION_CHANGE\");\n            }), e.event.addListener(g, \"drag\", function () {\n              v.dragTime_ = new Date().getTime(), v._onDrag(g);\n            }), e.event.addListener(g, \"dragend\", function () {\n              var o = e.event.addListener(g, \"idle\", function () {\n                e.event.removeListener(o), v._onDragEnd(g);\n              });\n            }), e.event.addListener(g, \"maptypeid_changed\", function () {\n              v._onMapTypeIdChange(g.getMapTypeId());\n            });\n          }\n        }).catch(function (e) {\n          throw i._onGoogleApiLoaded({\n            map: null,\n            maps: null,\n            ref: i.googleMapDom_\n          }), console.error(e), e;\n        });\n      }\n    }, i._onGoogleApiLoaded = function () {\n      var e;\n      i.props.onGoogleApiLoaded && (\"production\" !== process.env.NODE_ENV && !0 !== i.props.yesIWantToUseGoogleMapApiInternals && console.warn(\"GoogleMap: Usage of internal api objects is dangerous and can cause a lot of issues.\\nTo hide this warning add yesIWantToUseGoogleMapApiInternals={true} to <GoogleMap instance\"), (e = i.props).onGoogleApiLoaded.apply(e, arguments));\n    }, i._getHoverDistance = function () {\n      return i.props.hoverDistance;\n    }, i._onDrag = function () {\n      var e;\n      return i.props.onDrag && (e = i.props).onDrag.apply(e, arguments);\n    }, i._onDragEnd = function () {\n      var e;\n      return i.props.onDragEnd && (e = i.props).onDragEnd.apply(e, arguments);\n    }, i._onMapTypeIdChange = function () {\n      var e;\n      return i.props.onMapTypeIdChange && (e = i.props).onMapTypeIdChange.apply(e, arguments);\n    }, i._onZoomAnimationStart = function () {\n      var e;\n      return i.props.onZoomAnimationStart && (e = i.props).onZoomAnimationStart.apply(e, arguments);\n    }, i._onZoomAnimationEnd = function () {\n      var e;\n      return i.props.onZoomAnimationEnd && (e = i.props).onZoomAnimationEnd.apply(e, arguments);\n    }, i._onTilesLoaded = function () {\n      return i.props.onTilesLoaded && i.props.onTilesLoaded();\n    }, i._onChildClick = function () {\n      var e;\n      if (i.props.onChildClick) return (e = i.props).onChildClick.apply(e, arguments);\n    }, i._onChildMouseDown = function (e, o) {\n      i.childMouseDownArgs_ = [e, o], i.props.onChildMouseDown && i.props.onChildMouseDown(e, o, s({}, i.mouse_));\n    }, i._onChildMouseUp = function () {\n      var e;\n      i.childMouseDownArgs_ && (i.props.onChildMouseUp && (e = i.props).onChildMouseUp.apply(e, i.childMouseDownArgs_.concat([s({}, i.mouse_)])), i.childMouseDownArgs_ = null, i.childMouseUpTime_ = new Date().getTime());\n    }, i._onChildMouseMove = function () {\n      var e;\n      i.childMouseDownArgs_ && i.props.onChildMouseMove && (e = i.props).onChildMouseMove.apply(e, i.childMouseDownArgs_.concat([s({}, i.mouse_)]));\n    }, i._onChildMouseEnter = function () {\n      var e;\n      if (i.props.onChildMouseEnter) return (e = i.props).onChildMouseEnter.apply(e, arguments);\n    }, i._onChildMouseLeave = function () {\n      var e;\n      if (i.props.onChildMouseLeave) return (e = i.props).onChildMouseLeave.apply(e, arguments);\n    }, i._setViewSize = function () {\n      if (i.mounted_) {\n        if (document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) i.geoService_.setViewSize(window.innerWidth, window.innerHeight);else {\n          var e = n.findDOMNode(i.googleMapDom_);\n          i.geoService_.setViewSize(e.clientWidth, e.clientHeight);\n        }\n\n        i._onBoundsChanged();\n      }\n    }, i._onWindowResize = function () {\n      i.resetSizeOnIdle_ = !0;\n    }, i._onMapMouseMove = function (e) {\n      if (i.mouseInMap_) {\n        var o = new Date().getTime();\n        o - i.mouseMoveTime_ > 50 && (i.boundingRect_ = e.currentTarget.getBoundingClientRect()), i.mouseMoveTime_ = o;\n        var t = e.clientX - i.boundingRect_.left,\n            n = e.clientY - i.boundingRect_.top;\n        i.mouse_ || (i.mouse_ = {\n          x: 0,\n          y: 0,\n          lat: 0,\n          lng: 0\n        }), i.mouse_.x = t, i.mouse_.y = n;\n        var r = i.geoService_.fromContainerPixelToLatLng(i.mouse_);\n        i.mouse_.lat = r.lat, i.mouse_.lng = r.lng, i._onChildMouseMove(), o - i.dragTime_ < 100 ? i.fireMouseEventOnIdle_ = !0 : (i.markersDispatcher_.emit(\"kON_MOUSE_POSITION_CHANGE\"), i.fireMouseEventOnIdle_ = !1);\n      }\n    }, i._onClick = function () {\n      var e;\n      return i.props.onClick && !i.childMouseDownArgs_ && new Date().getTime() - i.childMouseUpTime_ > 300 && 0 === i.dragTime_ && (e = i.props).onClick.apply(e, arguments);\n    }, i._onMapClick = function (e) {\n      i.markersDispatcher_ && (i._onMapMouseMove(e), new Date().getTime() - i.dragTime_ > 100 && (i.mouse_ && i._onClick(s({}, i.mouse_, {\n        event: e\n      })), i.markersDispatcher_.emit(\"kON_CLICK\", e)));\n    }, i._onMapMouseDownNative = function (e) {\n      i.mouseInMap_ && i._onMapMouseDown(e);\n    }, i._onMapMouseDown = function (e) {\n      i.markersDispatcher_ && new Date().getTime() - i.dragTime_ > 100 && (i._onMapMouseMove(e), i.markersDispatcher_.emit(\"kON_MDOWN\", e));\n    }, i._onMapMouseDownCapture = function () {\n      Z().isChrome && (i.zoomControlClickTime_ = new Date().getTime());\n    }, i._onKeyDownCapture = function () {\n      Z().isChrome && (i.zoomControlClickTime_ = new Date().getTime());\n    }, i._isCenterDefined = function (e) {\n      return e && (U(e) && I(e.lat) && I(e.lng) || 2 === e.length && I(e[0]) && I(e[1]));\n    }, i._onBoundsChanged = function (e, o, t) {\n      if (e) {\n        var n = e.getCenter();\n        i.geoService_.setView([n.lat(), n.lng()], e.getZoom(), 0);\n      }\n\n      if ((i.props.onChange || i.props.onBoundsChange) && i.geoService_.canProject()) {\n        var r = i.geoService_.getZoom(),\n            a = i.geoService_.getBounds(),\n            p = i.geoService_.getCenter();\n\n        if (!function (e, o, t) {\n          if (e && o) {\n            for (var n = 0; n !== e.length; ++n) if (Math.abs(e[n] - o[n]) > 1e-5) return !1;\n\n            return !0;\n          }\n\n          return !1;\n        }(a, i.prevBounds_) && !1 !== t) {\n          var l = i.geoService_.getBounds(i.props.margin);\n          i.props.onBoundsChange && i.props.onBoundsChange(i.centerIsObject_ ? s({}, p) : [p.lat, p.lng], r, a, l), i.props.onChange && i.props.onChange({\n            center: s({}, p),\n            zoom: r,\n            bounds: {\n              nw: {\n                lat: a[0],\n                lng: a[1]\n              },\n              se: {\n                lat: a[2],\n                lng: a[3]\n              },\n              sw: {\n                lat: a[4],\n                lng: a[5]\n              },\n              ne: {\n                lat: a[6],\n                lng: a[7]\n              }\n            },\n            marginBounds: {\n              nw: {\n                lat: l[0],\n                lng: l[1]\n              },\n              se: {\n                lat: l[2],\n                lng: l[3]\n              },\n              sw: {\n                lat: l[4],\n                lng: l[5]\n              },\n              ne: {\n                lat: l[6],\n                lng: l[7]\n              }\n            },\n            size: i.geoService_.hasSize() ? {\n              width: i.geoService_.getWidth(),\n              height: i.geoService_.getHeight()\n            } : {\n              width: 0,\n              height: 0\n            }\n          }), i.prevBounds_ = a;\n        }\n      }\n    }, i._registerChild = function (e) {\n      i.googleMapDom_ = e;\n    }, i.mounted_ = !1, i.initialized_ = !1, i.googleApiLoadedCalled_ = !1, i.map_ = null, i.maps_ = null, i.prevBounds_ = null, i.heatmap = null, i.layers_ = {}, i.mouse_ = null, i.mouseMoveTime_ = 0, i.boundingRect_ = null, i.mouseInMap_ = !0, i.dragTime_ = 0, i.fireMouseEventOnIdle_ = !1, i.updateCounter_ = 0, i.markersDispatcher_ = new h(p(i)), i.geoService_ = new x(256), i.centerIsObject_ = U(i.props.center), i.minZoom_ = 3, i.defaultDraggableOption_ = !0, i.zoomControlClickTime_ = 0, i.childMouseDownArgs_ = null, i.childMouseUpTime_ = 0, i.googleMapDom_ = null, \"production\" !== process.env.NODE_ENV && (i.props.apiKey && console.warn(\"GoogleMap: apiKey is deprecated, use bootstrapURLKeys={{key: YOUR_API_KEY}} instead.\"), i.props.onBoundsChange && console.warn(\"GoogleMap: onBoundsChange is deprecated, use onChange({center, zoom, bounds, ...other}) instead.\"), P(i.props.center) && P(i.props.defaultCenter) && console.warn(\"GoogleMap: center or defaultCenter property must be defined\"), P(i.props.zoom) && P(i.props.defaultZoom) && console.warn(\"GoogleMap: zoom or defaultZoom property must be defined\")), i._isCenterDefined(i.props.center || i.props.defaultCenter)) {\n      var r = pe(i.props.center || i.props.defaultCenter);\n      i.geoService_.setView(r, i.props.zoom || i.props.defaultZoom, 0);\n    }\n\n    return i.zoomAnimationInProgress_ = !1, i.state = {\n      overlay: null\n    }, i;\n  }\n\n  a(t, o);\n  var i = t.prototype;\n  return i.componentDidMount = function () {\n    var e = this;\n    this.mounted_ = !0, H(window, \"resize\", this._onWindowResize, !1), H(window, \"keydown\", this._onKeyDownCapture, !0);\n    var o = n.findDOMNode(this.googleMapDom_);\n    o && H(o, \"mousedown\", this._onMapMouseDownNative, !0), H(window, \"mouseup\", this._onChildMouseUp, !1);\n    var t = s({}, this.props.apiKey && {\n      key: this.props.apiKey\n    }, this.props.bootstrapURLKeys);\n    this.props.googleMapLoader(t, this.props.heatmapLibrary), setTimeout(function () {\n      e._setViewSize(), e._isCenterDefined(e.props.center || e.props.defaultCenter) && e._initMap();\n    }, 0, this), this.props.resetBoundsOnResize && function (e, o) {\n      if (void 0 === e.parentNode) {\n        var t = document.createElement(\"div\");\n        e.parentNode = t;\n      }\n\n      e = e.parentNode, B ? e.attachEvent(\"onresize\", o) : (e.__resizeTriggers__ || (\"static\" == getComputedStyle(e).position && (e.style.position = \"relative\"), function () {\n        if (!W) {\n          var e = (ie || \"\") + \".resize-triggers { \" + (re || \"\") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\n              o = document.head || document.getElementsByTagName(\"head\")[0],\n              t = document.createElement(\"style\");\n          t.type = \"text/css\", t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e)), o.appendChild(t), W = !0;\n        }\n      }(), e.__resizeLast__ = {}, e.__resizeListeners__ = [], (e.__resizeTriggers__ = document.createElement(\"div\")).className = \"resize-triggers\", e.__resizeTriggers__.innerHTML = '<div class=\"expand-trigger\"><div></div></div><div class=\"contract-trigger\"></div>', e.appendChild(e.__resizeTriggers__), $(e), H(e, \"scroll\", q, !0), J && e.__resizeTriggers__.addEventListener(J, function (o) {\n        o.animationName == ne && $(e);\n      })), e.__resizeListeners__.push(o));\n    }(o, this._mapDomResizeCallback);\n  }, i.UNSAFE_componentWillReceiveProps = function (e) {\n    var o = this;\n\n    if (\"production\" !== process.env.NODE_ENV && (g(this.props.defaultCenter, e.defaultCenter) || console.warn(\"GoogleMap: defaultCenter prop changed. You can't change default props.\"), g(this.props.defaultZoom, e.defaultZoom) || console.warn(\"GoogleMap: defaultZoom prop changed. You can't change default props.\")), !this._isCenterDefined(this.props.center) && this._isCenterDefined(e.center) && setTimeout(function () {\n      return o._initMap();\n    }, 0), this.map_) {\n      var t = this.geoService_.getCenter();\n\n      if (this._isCenterDefined(e.center)) {\n        var n = pe(e.center),\n            i = this._isCenterDefined(this.props.center) ? pe(this.props.center) : null;\n        (!i || Math.abs(n.lat - i.lat) + Math.abs(n.lng - i.lng) > 1e-5) && Math.abs(n.lat - t.lat) + Math.abs(n.lng - t.lng) > 1e-5 && this.map_.panTo({\n          lat: n.lat,\n          lng: n.lng\n        });\n      }\n\n      if (P(e.zoom) || Math.abs(e.zoom - this.props.zoom) > 0 && this.map_.setZoom(e.zoom), !P(this.props.draggable) && P(e.draggable) ? this.map_.setOptions({\n        draggable: this.defaultDraggableOption_\n      }) : g(this.props.draggable, e.draggable) || this.map_.setOptions({\n        draggable: e.draggable\n      }), !P(e.options) && !g(this.props.options, e.options)) {\n        var r = E(this.maps_, U),\n            s = \"function\" == typeof e.options ? e.options(r) : e.options;\n\n        if (\"minZoom\" in (s = c(s, [\"zoom\", \"center\", \"draggable\"]))) {\n          var a = this._computeMinZoom(s.minZoom);\n\n          s.minZoom = le(s.minZoom, a);\n        }\n\n        this.map_.setOptions(s);\n      }\n\n      g(e.layerTypes, this.props.layerTypes) || (Object.keys(this.layers_).forEach(function (e) {\n        o.layers_[e].setMap(null), delete o.layers_[e];\n      }), this._setLayers(e.layerTypes)), this.heatmap && !g(e.heatmap.positions, this.props.heatmap.positions) && this.heatmap.setData(e.heatmap.positions.map(function (e) {\n        return {\n          location: new o.maps_.LatLng(e.lat, e.lng),\n          weight: e.weight\n        };\n      })), this.heatmap && !g(e.heatmap.options, this.props.heatmap.options) && Object.keys(e.heatmap.options).forEach(function (t) {\n        o.heatmap.set(t, e.heatmap.options[t]);\n      });\n    }\n  }, i.shouldComponentUpdate = function (e, o) {\n    return !g(c(this.props, [\"draggable\"]), c(e, [\"draggable\"])) || !g(this.state, o);\n  }, i.componentDidUpdate = function (e) {\n    this.markersDispatcher_.emit(\"kON_CHANGE\"), g(this.props.hoverDistance, e.hoverDistance) || this.markersDispatcher_.emit(\"kON_MOUSE_POSITION_CHANGE\");\n  }, i.componentWillUnmount = function () {\n    this.mounted_ = !1;\n    var e,\n        o,\n        t = n.findDOMNode(this.googleMapDom_);\n    t && t.removeEventListener(\"mousedown\", this._onMapMouseDownNative, !0), window.removeEventListener(\"resize\", this._onWindowResize), window.removeEventListener(\"keydown\", this._onKeyDownCapture), window.removeEventListener(\"mouseup\", this._onChildMouseUp, !1), this.props.resetBoundsOnResize && (o = this._mapDomResizeCallback, e = (e = t).parentNode, B ? e.detachEvent(\"onresize\", o) : (e.__resizeListeners__.splice(e.__resizeListeners__.indexOf(o), 1), e.__resizeListeners__.length || (e.removeEventListener(\"scroll\", q), e.__resizeTriggers__ = !e.removeChild(e.__resizeTriggers__)))), this.overlay_ && this.overlay_.setMap(null), this.maps_ && this.map_ && this.props.shouldUnregisterMapOnUnmount && (this.map_.setOptions({\n      scrollwheel: !1\n    }), this.maps_.event.clearInstanceListeners(this.map_)), this.props.shouldUnregisterMapOnUnmount && (this.map_ = null, this.maps_ = null), this.markersDispatcher_.dispose(), this.resetSizeOnIdle_ = !1, this.props.shouldUnregisterMapOnUnmount && (delete this.map_, delete this.markersDispatcher_);\n  }, i.render = function () {\n    var o = this.state.overlay,\n        t = o ? null : e.createElement(y, {\n      experimental: this.props.experimental,\n      onChildClick: this._onChildClick,\n      onChildMouseDown: this._onChildMouseDown,\n      onChildMouseEnter: this._onChildMouseEnter,\n      onChildMouseLeave: this._onChildMouseLeave,\n      geoService: this.geoService_,\n      insideMapPanes: !1,\n      distanceToMouse: this.props.distanceToMouse,\n      getHoverDistance: this._getHoverDistance,\n      dispatcher: this.markersDispatcher_\n    });\n    return e.createElement(\"div\", {\n      style: this.props.style,\n      onMouseMove: this._onMapMouseMove,\n      onMouseDownCapture: this._onMapMouseDownCapture,\n      onClick: this._onMapClick\n    }, e.createElement(u, {\n      registerChild: this._registerChild\n    }), se && o && ae(this._renderPortal(), o), t);\n  }, t;\n}(o);\n\nfunction he(e) {\n  var o = e.lng,\n      t = Math.sin(e.lat * Math.PI / 180),\n      n = o / 360 + .5,\n      i = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n  return {\n    x: n,\n    y: i = i < 0 ? 0 : i > 1 ? 1 : i\n  };\n}\n\nfunction ce(e) {\n  var o = e.x,\n      t = Math.PI - 2 * Math.PI * e.y;\n  return {\n    lat: 180 / Math.PI * Math.atan(.5 * (Math.exp(t) - Math.exp(-t))),\n    lng: 360 * o - 180\n  };\n}\n\nfunction de(e, o, t, n) {\n  var i = he(e),\n      r = he(o),\n      s = i.x < r.x ? r.x - i.x : 1 - i.x + r.x,\n      a = r.y - i.y;\n  if (s <= 0 && a <= 0) return null;\n\n  var p = T(t / 256 / Math.abs(s)),\n      l = T(n / 256 / Math.abs(a)),\n      u = Math.floor(1e-9 + Math.min(p, l)),\n      h = {\n    x: i.x < r.x ? .5 * (i.x + r.x) : i.x + r.x - 1 > 0 ? .5 * (i.x + r.x - 1) : .5 * (1 + i.x + r.x),\n    y: .5 * (i.y + r.y)\n  },\n      c = Math.pow(2, u),\n      d = t / c / 256 / 2,\n      m = n / c / 256 / 2,\n      g = ce({\n    x: h.x - d,\n    y: h.y - m\n  }),\n      _ = ce({\n    x: h.x + d,\n    y: h.y + m\n  });\n\n  return {\n    center: ce(h),\n    zoom: u,\n    newBounds: {\n      nw: g,\n      se: _\n    }\n  };\n}\n\nfunction me(e) {\n  var o = e.ne,\n      t = e.sw;\n  return {\n    nw: {\n      lat: o.lat,\n      lng: t.lng\n    },\n    se: {\n      lat: t.lat,\n      lng: o.lng\n    }\n  };\n}\n\nfunction ge(e) {\n  var o = e.nw,\n      t = e.se;\n  return {\n    ne: {\n      lat: o.lat,\n      lng: t.lng\n    },\n    sw: {\n      lat: t.lat,\n      lng: o.lng\n    }\n  };\n}\n\nfunction _e(e, o) {\n  var t,\n      n = e.nw,\n      i = e.se,\n      r = e.ne,\n      a = e.sw,\n      p = o.width,\n      l = o.height;\n  if (n && i) t = de(n, i, p, l);else {\n    var u = me({\n      ne: r,\n      sw: a\n    });\n    t = de(u.nw, u.se, p, l);\n  }\n  return s({}, t, {\n    newBounds: s({}, t.newBounds, ge(t.newBounds))\n  });\n}\n\nfunction fe(e, o, t) {\n  var n = function (e, o) {\n    var t = function (e, o) {\n      var t,\n          n = o.lat,\n          i = o.lng,\n          r = (t = n * Math.PI / 180, {\n        metersPerLatDegree: 111132.92 - 559.82 * Math.cos(2 * t) + 1.175 * Math.cos(4 * t) - .0023 * Math.cos(6 * t),\n        metersPerLngDegree: 111412.84 * Math.cos(t) - 93.5 * Math.cos(3 * t) + .118 * Math.cos(5 * t)\n      }),\n          s = .5 * e / r.metersPerLatDegree,\n          a = .5 * e / r.metersPerLngDegree;\n      return {\n        nw: {\n          lat: n - s,\n          lng: i - a\n        },\n        se: {\n          lat: n + s,\n          lng: i + a\n        }\n      };\n    }(e, {\n      lat: o.lat,\n      lng: o.lng\n    }),\n        n = t.se,\n        i = he(t.nw),\n        r = he(n);\n\n    return {\n      w: Math.abs(r.x - i.x),\n      h: Math.abs(r.y - i.y)\n    };\n  }(e, {\n    lat: o.lat,\n    lng: o.lng\n  }),\n      i = n.w,\n      r = n.h,\n      s = Math.pow(2, t);\n\n  return {\n    w: i * s * 256,\n    h: r * s * 256\n  };\n}\n\nfunction ve(e, o) {\n  var t = e.x,\n      n = Math.PI - 2 * Math.PI * e.y / Math.pow(2, o);\n  return {\n    lat: 180 / Math.PI * Math.atan(.5 * (Math.exp(n) - Math.exp(-n))),\n    lng: t / Math.pow(2, o) * 360 - 180\n  };\n}\n\nfunction Me(e, o) {\n  var t = he({\n    lat: e.lat,\n    lng: e.lng\n  }),\n      n = Math.pow(2, o);\n  return {\n    x: Math.floor(t.x * n),\n    y: Math.floor(t.y * n)\n  };\n}\n\nfunction ye(e, o) {\n  for (var t = e.from, n = e.to, i = Math.pow(2, o), r = [], s = t.x; s !== (n.x + 1) % i; s = (s + 1) % i) for (var a = t.y; a !== (n.y + 1) % i; a = (a + 1) % i) r.push([o, s, a]);\n\n  return r;\n}\n\nue.propTypes = {\n  apiKey: t.string,\n  bootstrapURLKeys: t.any,\n  defaultCenter: t.oneOfType([t.array, t.shape({\n    lat: t.number,\n    lng: t.number\n  })]),\n  center: t.oneOfType([t.array, t.shape({\n    lat: t.number,\n    lng: t.number\n  })]),\n  defaultZoom: t.number,\n  zoom: t.number,\n  onBoundsChange: t.func,\n  onChange: t.func,\n  onClick: t.func,\n  onChildClick: t.func,\n  onChildMouseDown: t.func,\n  onChildMouseUp: t.func,\n  onChildMouseMove: t.func,\n  onChildMouseEnter: t.func,\n  onChildMouseLeave: t.func,\n  onZoomAnimationStart: t.func,\n  onZoomAnimationEnd: t.func,\n  onDrag: t.func,\n  onDragEnd: t.func,\n  onMapTypeIdChange: t.func,\n  onTilesLoaded: t.func,\n  options: t.any,\n  distanceToMouse: t.func,\n  hoverDistance: t.number,\n  debounced: t.bool,\n  margin: t.array,\n  googleMapLoader: t.any,\n  onGoogleApiLoaded: t.func,\n  yesIWantToUseGoogleMapApiInternals: t.bool,\n  draggable: t.bool,\n  style: t.any,\n  resetBoundsOnResize: t.bool,\n  layerTypes: t.arrayOf(t.string),\n  shouldUnregisterMapOnUnmount: t.bool\n}, ue.defaultProps = {\n  distanceToMouse: function (e, o) {\n    return Math.sqrt((e.x - o.x) * (e.x - o.x) + (e.y - o.y) * (e.y - o.y));\n  },\n  hoverDistance: 30,\n  debounced: !0,\n  options: function () {\n    return {\n      overviewMapControl: !1,\n      streetViewControl: !1,\n      rotateControl: !0,\n      mapTypeControl: !1,\n      styles: [{\n        featureType: \"poi\",\n        elementType: \"labels\",\n        stylers: [{\n          visibility: \"off\"\n        }]\n      }],\n      minZoom: 3\n    };\n  },\n  googleMapLoader: D,\n  yesIWantToUseGoogleMapApiInternals: !1,\n  style: {\n    width: \"100%\",\n    height: \"100%\",\n    margin: 0,\n    padding: 0,\n    position: \"relative\"\n  },\n  layerTypes: [],\n  heatmap: {},\n  heatmapLibrary: !1,\n  shouldUnregisterMapOnUnmount: !0\n}, ue.googleMapLoader = D;\nexport default ue;\nexport { me as convertNeSwToNwSe, ge as convertNwSeToNeSw, _e as fitBounds, ye as getTilesIds, Me as latLng2Tile, fe as meters2ScreenPixels, ve as tile2LatLng };","map":null,"metadata":{},"sourceType":"module"}